# memo
## OpenStatusChangeService
- base逻辑：OpenStatusChangeService-Origin.java
- Copilot优化后逻辑：OpenStatusChangeService-Copilot.java
### base逻辑
业务流程有两种，都是更新系业务：
- 将多条业务数据的状态从未公开设定成公开，applyOpen
- 将一条业务数据的状态从公开还原成未公开，cancelOpen

该业务的特殊的部分在于，根据TypeEnum的种类不同，更新的实体对象不同。但是另一方面，更新操作的表都是单表，并且这些表的结构类似。（实际上从表结构和业务的设计上优化更有意义）<br/>
<br/>
对此为了尽可能的复用代码，尽可能的抽出共通逻辑：<br/>
<br/>
因为表结构的类似，更新参数的OpenStatusChangeDto，和更新后返回的展示结构CountResultDto可以复用。通过对象属性中的TypeEnum做不同实体的区分。<br/>
<br/>
不同的举对应不同的业务方法。考虑到此时的枚举数量已经多达5个，后续有有进一步扩展的可能。所以比起使用大量的增强switch或大量的if判断，想将通过枚举选择具体业务方法的处理抽离出来。<br/>
<br/>
枚举和业务方法，以枚举和lambda的key-value的形式，注册成一个openStatusChangeHandlerMap。业务方法的具体执行，只需要通过枚举取得lambda执行，不需要考虑判断逻辑（对应方法：dispatch）。<br/>
<br/>
然后思考具体业务方法的复用：<br/>
<br/>
如果为每个实体的公开和未公开业务各写一个业务方法，就是10个方法。重复逻辑过多，也不好维护。<br/>
<br/>
同一张表的公开和未公开业务之间，有大量通用部分。大体逻辑上都是，检索db数据，做业务校验，通过校验后更新db，更新后把新的实体映射成前端需要的格式返回。<br/>
<br/>
公开和未公开的业务的不同集中在业务校验，和状态值更新的部分，所以保留共通的部分，不同的部分通过lambda作为参数传进来。这样公开和未公开业务抽离成了更新处理业务的共通方法。方法由10个缩减成5个。<br/>
<br/>
5个不同表之间的更新业务，也有着大量的重复逻辑。从行为上看，这写方法都是同一套业务流程，差别仅在于不同实体之间的具体操作。所以结合泛型和lambda把实体操作的行为抽象化，以参数的形式传进共通方法。于是抽象出方法handle。<br/>
<br/>
具体的方法handleTypeA等处理，只需要把不同实体的操作行为作为实际参数传进去即可。参考handleTypeA ~ handleTypeE。<br/>
